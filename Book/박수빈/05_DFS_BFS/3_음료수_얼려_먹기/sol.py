'''
4 5
00110
00011
11111
00000

15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111
'''
def DFS(i, j) :

    # arr[i][j]의 상하좌우를 살펴봐야 하기 때문에
    # i, j에서 상하좌우 좌표로 이동할 수 있는 값
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    # 원래 지나가지 않았던 곳을 지나갔기 때문에
    # arr[i][j]의 값을 1로 바꾼다
    if arr[i][j] == 0 :
        arr[i][j] = 1

        # 상하좌우를 살펴본다
        for k in range(4) :
            temp_x = i+dx[k]
            temp_y = j+dy[k]

            # 좌우 값이 0보다 작거나 N보다 크거나 같으면, 상하 값이 0보다 작거나 M보다 크거나 같으면
            # 범위를 벗어나기 때문에 넘긴다
            if temp_x < 0 or temp_x >= N or temp_y < 0 or temp_y >= M :
                continue
            # 그 밖의 값은 범위 안에  있다
            else :
                # arr[temp_x][temp_y]값이 0이라면 한 번도 지나가지 않았다는 뜻이므로
                # 함수 DFS에 인자 temp_x와 temp_y를 할당한다
                if arr[temp_x][temp_y] == 0 :
                    DFS(temp_x, temp_y)

# 세로N, 가로M 입력받기
N, M = map(int, input().split())

# 얼음틀을 2차원 리스트로 입력받기
arr = [list(map(int, input())) for _ in range(N)]

# 묶음을 세는 변수
cnt = 0

for i in range(N) :
    for j in range(M) :
            # 만약 arr[i][j]가 0이라면 한 번도 지나가지 않았으므로
            # 제일 처음에 0으로 입력받은 값이라도 arr[temp_x][temp_y]가 되어 
            # 1이 되었을 수도 있다
            # 그래서 여기에서 DFS(i, j)에 할당되는 값은 무조건 새로운 영역이기에
            # cnt에 1을 추가한다
            if arr[i][j] == 0 :
                DFS(i, j)   # 함수에 할당
                cnt += 1    # 1을 더한다

print(cnt)
